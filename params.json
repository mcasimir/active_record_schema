{"tagline":"A ruby gem for Rails that extends ActiveRecord with the capability to define fields for a model within the model itself and to generate migrations directly from models.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"ActiveRecord Schema","body":"# ActiveRecordSchema\r\n\r\n**ActiveRecordSchema** is an `ActiveRecord` extension that allows you to define fields for a model within the model itself and to generate migrations directly from models.\r\n\r\nUnlike other libraries ActiveRecordSchema is not an alternative to Rails migrations, but rather a tool to simplify their use.\r\n\r\n_ex._\r\n\r\n```\r\nrails g model Post title:string body:text --timestamps\r\n```\r\n\r\n``` rb\r\nclass Post < ActiveRecord::Base\r\n    field :title, :string\r\n    field :body, :text\r\n    \r\n    attr_accessible :date, :name\r\n    timestamps\r\nend\r\n```\r\n\r\n```\r\nrails g migration create_posts --from Post\r\n```\r\n\r\n## Features\r\n\r\n* Defining columns and indexes directly in model\r\n* Generation of migration from the model taking into account the current state of the database\r\n* Automatically add code to migrate associations:\r\n   * Foreign key for `belongs_to`\r\n   * Join table for `has_and_belongs_to_many`\r\n  \r\n* Automatic indexing of foreign keys for both `belongs_to` and `has_and_belongs_to_many` (configurable)\r\n\r\n## Installation\r\n\r\nPut this in your Gemfile\r\n\r\n    gem 'active_record_schema'\r\n    \r\nand update your bundle\r\n  \r\n    bundle install\r\n    \r\n**NOTE:** ActiveRecordSchema depends on `rails ~> 3.0` and not only `ActiveRecord`\r\n\r\n## Configuration\r\n\r\nIn order to correctly solve the required fields for the inheritance ActiveRecordSchema requires that all classes of models are loaded in memory when generating migration. This is done by pre-loading models in the generator. To figure out which file to load ARS refers to the global configuration property in `ActiveRecordSchema.config.autoload_paths` that is set by default to:\r\n\r\n``` rb\r\n[\r\n   Rails.root.join('app', 'models', '*.rb'),\r\n   Rails.root.join('app', 'models', '**', '*.rb') \r\n]\r\n```\r\n\r\nYou can change this by creating an initializer and setting or appending new paths to `ActiveRecordSchema.config.autoload_paths`\r\n\r\n\r\n``` rb\r\n# active_record_schema_initializer.rb\r\nActiveRecordSchema.config.autoload_paths << Rails.root.join('lib', 'models', '*.rb')\r\n```\r\n\r\n\r\n## Usage\r\n\r\nCreate a model and use the class method `#field` to define columns\r\n\r\n``` rb    \r\nclass Post < ActiveRecord::Base\r\n    field :title\r\n    field :body, :as => :text\r\n    belongs_to :author, :class_name => \"User\"\r\nend\r\n```\r\n\r\nNow run `rails g migration` with `--from` option\r\n\r\n    rails g migration init_posts_schema --from Post\r\n  \r\nand the following migration will be generated\r\n\r\n``` rb    \r\nclass InitPostsSchema < ActiveRecord::Migration\r\n  def change\r\n    create_table :posts \r\n    add_column :posts, :title, :string\r\n    add_column :posts, :body, :text\r\n\r\n    add_column :author_id, :integer\r\n    index :author_id\r\n  end\r\nend\r\n```\r\n\r\n**NOTE:** `create_table :posts` is added only if `posts` table does not exist yet\r\n\r\nGenerating a migration for new columns is the same, lets add a new field to `Post` (eg. `pubdate`):\r\n\r\n``` rb    \r\nclass Post < ActiveRecord::Base\r\n    field :title\r\n    field :body, :as => :text\r\n    belongs_to :author, :class_name => \"User\"\r\n    \r\n    field :pubdate, :as => :datetime\r\nend\r\n```\r\n\r\nNow run\r\n\r\n    rails g migration add_pubdate_to_posts --from Post\r\n\r\nthat will generate:\r\n\r\n``` rb\r\nclass AddPubdateToPosts < ActiveRecord::Migration\r\n  def change\r\n    add_column :posts, :pubdate, :datetime\r\n  end\r\nend\r\n```\r\n\r\n**NOTE:** No migration will be generated in case all changes are up-to-date \r\n\r\n## Has and Belongs To Many (HBTM) associations\r\n\r\nLets try to add a HBTM association to our `Post` model\r\n\r\n_ex._\r\n\r\n``` rb\r\n# post.rb\r\nclass Post < ActiveRecord::Base\r\n  field :title\r\n  field :body, :as => :text\r\n  belongs_to :author, :class_name => \"User\"\r\n  field :pubdate, :as => :datetime\r\n\r\n  has_and_belongs_to_many :voters, :class_name => \"User\"\r\nend\r\n```\r\n\r\n\r\nNow running\r\n\r\n    rails g migration add_voters_to_posts --from Post\r\n\r\nwill generate:\r\n\r\n``` rb\r\nclass AddVotersToPosts < ActiveRecord::Migration\r\n  def change\r\n    create_table :posts_users, :id => false do |t|\r\n      t.integer  \"post_id\"\r\n      t.integer  \"user_id\"\r\n    end\r\n    add_index :posts_users, \"post_id\"\r\n    add_index :posts_users, \"user_id\"\r\n  end\r\nend\r\n```\r\n\r\n## Single Table Inheritance (STI)\r\n\r\nCall `#inheritable` inside the base class of your hierarchy to add the inheritance column required by Single Table Inheritance.\r\n\r\n_ex._\r\n\r\n``` rb\r\n# content.rb\r\nclass Content < ActiveRecord::Base\r\n  inheritable\r\n  \r\n  field :title\r\n  \r\n  has_and_belongs_to_many :voters, :class_name => \"User\"\r\n  belongs_to              :author, :class_name => \"User\"\r\n    \r\n  timestamps\r\nend\r\n    \r\n  \r\n# article.rb\r\nclass Article < Content\r\n  field :body, :as => :text\r\nend\r\n    \r\n  \r\n# video.rb\r\nclass Video < Content\r\n  field :url\r\nend\r\n```\r\n\r\nRunning\r\n    \r\n    rails g migration init_contents --from Content\r\n\r\nsame as\r\n\r\n    rails g migration init_contents --from Article\r\n    \r\nsame as\r\n\r\n    rails g migration init_contents --from Video\r\n    \r\nwill generate the following migration \r\n\r\n``` rb\r\nclass InitContents < ActiveRecord::Migration\r\n  def change\r\n    add_column :contents, :type, :string\r\n    add_column :contents, :title, :string\r\n    add_column :contents, :author_id, :string\r\n    add_column :contents, :body, :text\r\n    add_column :contents, :url, :string\r\n\r\n    add_index :contents, :author_id\r\n\r\n    create_table :contents_users, :id => false do |t|\r\n      t.integer  \"content_id\"\r\n      t.integer  \"user_id\"\r\n    end\r\n    add_index :contents_users, \"content_id\"\r\n    add_index :contents_users, \"user_id\"\r\n  end  \r\nend\r\n```\r\n\r\n\r\n## Mixins\r\n\r\nProbably one of the most significant advantage given by ActiveRecordSchema is to allow the definition of fields in modules and reuse them through mixins\r\n\r\n_ex._\r\n\r\n``` rb\r\nmodule Profile\r\n  extend ActiveSupport::Concern\r\n  included do\r\n    field :name\r\n    field :age, :as => :integer\r\n      \r\n  end\r\nend\r\n    \r\nclass User < ActiveRecord::Base\r\n  include Profile\r\n  \r\nend\r\n    \r\nclass Player < ActiveRecord::Base\r\n  include Profile\r\n      \r\nend\r\n```\r\n\r\n\r\n## DSL (Domain Specific Language) reference\r\n\r\n  * ### `field(name, *args)`\r\n\r\n    Adds a new column with name `name` to the schema. The type of column can be passed either as second argument or as option, if not specified is intended to be `:string`\r\n\r\n    #### options  \r\n\r\n    * **:as** _or_ **:type** : Specify the type of the column. The value can be a `String`, a `Symbol` or a `Class`, default to `:string`\r\n    * **:index** : Specify wether or not the field should be indexed, default to `false`\r\n\r\n    #### examples\r\n\r\n    ``` rb\r\n    field :name\r\n\r\n    field :name, :string\r\n    field :name, \"string\"\r\n    field :name, String\r\n\r\n    field :name, :as => :string\r\n    field :name, :as => \"string\"\r\n    field :name, :as => String\r\n\r\n    field :name, :type => :string\r\n    field :name, :type => \"string\"\r\n    field :name, :type => String\r\n\r\n    field :age, :as => :integer, :index => true\r\n    ```\r\n\r\n\r\n  * ### `belongs_to(name, options = {})`\r\n\r\n    Adds a new foreign key column for the association to the schema and then delegates to `ActiveRecord::Base.belongs_to`. If the association is polymorphic a column for foreign type is also generated.\r\n\r\n    #### options  \r\n\r\n    * **:index** : Specify wether or not the foreing key column should be indexed, default to `true`. If the association is polymorphic creates an index on both foreign key and foreing type\r\n\r\n\r\n  * ### `has_and_belongs_to_many(name, options = {}, &extension)`\r\n\r\n    Adds a new join table for the association to the schema and then delegates to `ActiveRecord::Base.has_and_belongs_to_many`\r\n\r\n  * ### `index(column_name, options = {})`\r\n\r\n    Adds a new index for `column_name` column to the schema\r\n    \r\n  * ### `add_index(column_name, options = {})`\r\n\r\n    alias for `index`\r\n\r\n  * ### `timestamps`\r\n\r\n    Same as\r\n\r\n    ``` rb\r\n    field :created_at, :datetime\r\n    field :updated_at, :datetime\r\n    ```\r\n\r\n  * ### `inheritable`\r\n  \r\n    Same as\r\n\r\n    ``` rb\r\n    field :\"#{inheritance_column}\"\r\n    ```\r\n\r\n\r\n## Generators\r\n\r\n### `rails g model`\r\n\r\n``` \r\n      [--inheritable]          # Add 'inheritable' to the generated model\r\n      [--timestamps]           # Add 'timestamps' to the generated model\r\n      [--scope=SCOPE]          # The subpath of app/models in which model file will be created\r\n      [--parent=PARENT]        # The parent class for the generated model\r\n  -t, [--test-framework=NAME]  # Test framework to be invoked\r\n                               # Default: test_unit\r\n```\r\n\r\n### `rails g migration`\r\n\r\n```\r\n  [--from=FROM]  # calculates the changes to be applied on model table from the schema defined inside the model itself\r\n  [--id=N]       # The id to be used in this migration\r\n```\r\n\r\n## Why do not also generate irreversible changes (change/remove columns or indexes)?\r\n\r\nActiveRecordSchema does not take into account the removal of columns and indexes or changes in the types of columns. The reason for this is that these changes are not reversible, so it's a better idea to introduce them by hand rather than let them be generated automatically. Anyway the need to resort to harsh measures such as irreversible changes is limited to non-routine situations.\r\n\r\n\r\n## Contributing to active_record_schema\r\n \r\n* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet.\r\n* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it.\r\n* Fork the project.\r\n* Start a feature/bugfix branch.\r\n* Commit and push until you are happy with your contribution.\r\n* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.\r\n* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.\r\n\r\n---\r\n\r\nCopyright (c) 2012 mcasimir\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n"}